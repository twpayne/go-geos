// This file is automatically generated. DO NOT EDIT.

package geos

// #include "go-geos.h"
import "C"

import "unsafe"

// Area returns g's area.
func (g *Geom) Area() float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var area float64
	if C.GEOSArea_r(g.context.handle, g.geom, (*C.double)(&area)) == 0 {
		panic(g.context.err)
	}
	return area
}

// Boundary returns the boundary of g.
func (g *Geom) Boundary() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSBoundary_r(g.context.handle, g.geom), nil)
}

// Buffer returns g with the given buffer.
func (g *Geom) Buffer(width float64, quadsegs int) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSBuffer_r(g.context.handle, g.geom, C.double(width), C.int(quadsegs)), nil)
}

// BufferWithStyle returns a buffer using the provided style parameters.
func (g *Geom) BufferWithStyle(width float64, quadsegs int, endCapStyle BufCapStyle, joinStyle BufJoinStyle, mitreLimit float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSBufferWithStyle_r(g.context.handle, g.geom, C.double(width), C.int(quadsegs), C.int(endCapStyle), C.int(joinStyle), C.double(mitreLimit)), nil)
}

// BuildArea returns the polygonization using all the linework, assuming that rings contained within rings are empty holes, rather than extra PolygonHoleSimplify.
func (g *Geom) BuildArea() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSBuildArea_r(g.context.handle, g.geom), nil)
}

// Centroid returns a point at the center of mass of g.
func (g *Geom) Centroid() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSGetCentroid_r(g.context.handle, g.geom), nil)
}

// ClipByRect returns g clipped to a rectangular polygon.
func (g *Geom) ClipByRect(minX float64, minY float64, maxX float64, maxY float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSClipByRect_r(g.context.handle, g.geom, C.double(minX), C.double(minY), C.double(maxX), C.double(maxY)), nil)
}

// Clone returns a clone of g.
func (g *Geom) Clone() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSGeom_clone_r(g.context.handle, g.geom), nil)
}

// ConcaveHull returns the concave hull of g.
func (g *Geom) ConcaveHull(ratio float64, allowHoles uint) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSConcaveHull_r(g.context.handle, g.geom, C.double(ratio), C.unsigned(allowHoles)), nil)
}

// ConcaveHullByLength returns the concave hull of g.
func (g *Geom) ConcaveHullByLength(ratio float64, allowHoles uint) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSConcaveHullByLength_r(g.context.handle, g.geom, C.double(ratio), C.unsigned(allowHoles)), nil)
}

// ConstrainedDelaunayTriangulation returns the constrained Delaunay triangulation of the vertices of the g.
func (g *Geom) ConstrainedDelaunayTriangulation() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSConstrainedDelaunayTriangulation_r(g.context.handle, g.geom), nil)
}

// Contains returns true if g contains other.
func (g *Geom) Contains(other *Geom) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSContains_r(g.context.handle, g.geom, other.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// ConvexHull returns g's convex hull.
func (g *Geom) ConvexHull() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSConvexHull_r(g.context.handle, g.geom), nil)
}

// CoverageUnion returns the union of g for polygonal inputs that are correctly noded and do not overlap.
func (g *Geom) CoverageUnion() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSCoverageUnion_r(g.context.handle, g.geom), nil)
}

// CoveredBy returns true if g is covered by other.
func (g *Geom) CoveredBy(other *Geom) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSCoveredBy_r(g.context.handle, g.geom, other.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// Covers returns true if g covers other.
func (g *Geom) Covers(other *Geom) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSCovers_r(g.context.handle, g.geom, other.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// Crosses returns true if g crosses other.
func (g *Geom) Crosses(other *Geom) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSCrosses_r(g.context.handle, g.geom, other.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// Densify returns g densified with the given tolerance.
func (g *Geom) Densify(tolerance float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSDensify_r(g.context.handle, g.geom, C.double(tolerance)), nil)
}

// Difference returns the difference between g and other.
func (g *Geom) Difference(other *Geom) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSDifference_r(g.context.handle, g.geom, other.geom), nil)
}

// DifferencePrec returns the difference between g and other.
func (g *Geom) DifferencePrec(other *Geom, gridSize float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSDifferencePrec_r(g.context.handle, g.geom, other.geom, C.double(gridSize)), nil)
}

// Disjoint returns true if g is disjoint from other.
func (g *Geom) Disjoint(other *Geom) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSDisjoint_r(g.context.handle, g.geom, other.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// Distance returns the distance between the closes points on g and other.
func (g *Geom) Distance(other *Geom) float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var distance float64
	if C.GEOSDistance_r(g.context.handle, g.geom, other.geom, (*C.double)(&distance)) == 0 {
		panic(g.context.err)
	}
	return distance
}

// DistanceIndexed returns the distance between g and other, using the indexed facet distance.
func (g *Geom) DistanceIndexed(other *Geom) float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var distanceIndexed float64
	if C.GEOSDistanceIndexed_r(g.context.handle, g.geom, other.geom, (*C.double)(&distanceIndexed)) == 0 {
		panic(g.context.err)
	}
	return distanceIndexed
}

// DistanceWithin returns whether the distance between g and other is within the given dist.
func (g *Geom) DistanceWithin(other *Geom, dist float64) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSDistanceWithin_r(g.context.handle, g.geom, other.geom, C.double(dist)) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// EndPoint returns the last point of a LineString.
func (g *Geom) EndPoint() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSGeomGetEndPoint_r(g.context.handle, g.geom), nil)
}

// Envelope returns the envelope of g.
func (g *Geom) Envelope() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSEnvelope_r(g.context.handle, g.geom), nil)
}

// Equals returns true if g equals other.
func (g *Geom) Equals(other *Geom) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSEquals_r(g.context.handle, g.geom, other.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// EqualsExact returns true if g equals other exactly.
func (g *Geom) EqualsExact(other *Geom, tolerance float64) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSEqualsExact_r(g.context.handle, g.geom, other.geom, C.double(tolerance)) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// FrechetDistance returns the Fréchet distance between g and other.
func (g *Geom) FrechetDistance(other *Geom) float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var frechetDistance float64
	if C.GEOSFrechetDistance_r(g.context.handle, g.geom, other.geom, (*C.double)(&frechetDistance)) == 0 {
		panic(g.context.err)
	}
	return frechetDistance
}

// FrechetDistanceDensify returns the Fréchet distance between g and other.
func (g *Geom) FrechetDistanceDensify(other *Geom, densifyFrac float64) float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var frechetDistanceDensify float64
	if C.GEOSFrechetDistanceDensify_r(g.context.handle, g.geom, other.geom, C.double(densifyFrac), (*C.double)(&frechetDistanceDensify)) == 0 {
		panic(g.context.err)
	}
	return frechetDistanceDensify
}

// HasZ returns if g has Z coordinates.
func (g *Geom) HasZ() bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSHasZ_r(g.context.handle, g.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// HausdorffDistance returns the Hausdorff distance between g and other.
func (g *Geom) HausdorffDistance(other *Geom) float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var hausdorffDistance float64
	if C.GEOSHausdorffDistance_r(g.context.handle, g.geom, other.geom, (*C.double)(&hausdorffDistance)) == 0 {
		panic(g.context.err)
	}
	return hausdorffDistance
}

// HausdorffDistanceDensify returns the Hausdorff distance between g and other.
func (g *Geom) HausdorffDistanceDensify(other *Geom, densifyFrac float64) float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var hausdorffDistanceDensify float64
	if C.GEOSHausdorffDistanceDensify_r(g.context.handle, g.geom, other.geom, C.double(densifyFrac), (*C.double)(&hausdorffDistanceDensify)) == 0 {
		panic(g.context.err)
	}
	return hausdorffDistanceDensify
}

// Interpolate returns a point distance d from the start of g, which must be a linestring.
func (g *Geom) Interpolate(d float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSInterpolate_r(g.context.handle, g.geom, C.double(d)), nil)
}

// InterpolateNormalized returns the point that is at proportion from the start.
func (g *Geom) InterpolateNormalized(proportion float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSInterpolateNormalized_r(g.context.handle, g.geom, C.double(proportion)), nil)
}

// Intersection returns the intersection of g and other.
func (g *Geom) Intersection(other *Geom) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSIntersection_r(g.context.handle, g.geom, other.geom), nil)
}

// IntersectionPrec returns the intersection of g and other.
func (g *Geom) IntersectionPrec(other *Geom, gridSize float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSIntersectionPrec_r(g.context.handle, g.geom, other.geom, C.double(gridSize)), nil)
}

// Intersects returns true if g intersects other.
func (g *Geom) Intersects(other *Geom) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSIntersects_r(g.context.handle, g.geom, other.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// IsClosed returns true if g is closed.
func (g *Geom) IsClosed() bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSisClosed_r(g.context.handle, g.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// IsEmpty returns true if g is empty.
func (g *Geom) IsEmpty() bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSisEmpty_r(g.context.handle, g.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// IsRing returns true if g is a ring.
func (g *Geom) IsRing() bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSisRing_r(g.context.handle, g.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// IsSimple returns true if g is simple.
func (g *Geom) IsSimple() bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSisSimple_r(g.context.handle, g.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// IsValid returns true if g is valid.
func (g *Geom) IsValid() bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSisValid_r(g.context.handle, g.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// LargestEmptyCircle returns the largest empty circle for g, up to a specified tolerance.
func (g *Geom) LargestEmptyCircle(other *Geom, tolerance float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSLargestEmptyCircle_r(g.context.handle, g.geom, other.geom, C.double(tolerance)), nil)
}

// Length returns g's length.
func (g *Geom) Length() float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var length float64
	if C.GEOSLength_r(g.context.handle, g.geom, (*C.double)(&length)) == 0 {
		panic(g.context.err)
	}
	return length
}

// LineMerge returns a set of fully noded LineStrings, removing any cardinality 2 nodes in the linework.
func (g *Geom) LineMerge() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSLineMerge_r(g.context.handle, g.geom), nil)
}

// MakeValid repairs an invalid geometry, returning a valid output.
func (g *Geom) MakeValid() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSMakeValid_r(g.context.handle, g.geom), nil)
}

// MaximumInscribedCircle returns the maximum inscribed circle of g up to the the given tolerance.
func (g *Geom) MaximumInscribedCircle(tolerance float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSMaximumInscribedCircle_r(g.context.handle, g.geom, C.double(tolerance)), nil)
}

// MinimumClearance returns the minimum clearance of g.
func (g *Geom) MinimumClearance() float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var minimumClearance float64
	if C.GEOSMinimumClearance_r(g.context.handle, g.geom, (*C.double)(&minimumClearance)) == 0 {
		panic(g.context.err)
	}
	return minimumClearance
}

// MinimumClearanceLine returns a LineString whose endpoints define the minimum clearance of g.
func (g *Geom) MinimumClearanceLine() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSMinimumClearanceLine_r(g.context.handle, g.geom), nil)
}

// MinimumRotatedRectangle returns the minimum rotated rectangle enclosing g.
func (g *Geom) MinimumRotatedRectangle() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSMinimumRotatedRectangle_r(g.context.handle, g.geom), nil)
}

// MinimumWidth returns a linestring geometry which represents the minimum diameter of g.
func (g *Geom) MinimumWidth() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSMinimumWidth_r(g.context.handle, g.geom), nil)
}

// Node returns a new geometry in which no lines cross each other, and all touching occurs at endpoints.
func (g *Geom) Node() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSNode_r(g.context.handle, g.geom), nil)
}

// OffsetCurve returns the offset curve line(s) of g.
func (g *Geom) OffsetCurve(width float64, quadsegs int, joinStyle BufJoinStyle, mitreLimit float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSOffsetCurve_r(g.context.handle, g.geom, C.double(width), C.int(quadsegs), C.int(joinStyle), C.double(mitreLimit)), nil)
}

// Overlaps returns true if g overlaps other.
func (g *Geom) Overlaps(other *Geom) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSOverlaps_r(g.context.handle, g.geom, other.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// PointOnSurface returns a point that is inside the boundary of a polygonal geometry.
func (g *Geom) PointOnSurface() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSPointOnSurface_r(g.context.handle, g.geom), nil)
}

// Project returns the distance of other(a point) projected onto g(a line) from the start of the line.
func (g *Geom) Project(other *Geom) float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return float64(C.GEOSProject_r(g.context.handle, g.geom, other.geom))
}

// ProjectNormalized returns the proportional distance of other(a point) projected onto g(a line) from the start of the line. For example, a point that projects to the middle of a line would be return 0.5.
func (g *Geom) ProjectNormalized(other *Geom) float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return float64(C.GEOSProjectNormalized_r(g.context.handle, g.geom, other.geom))
}

// Relate returns the DE9IM pattern for g and other.
func (g *Geom) Relate(other *Geom) string {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	relateCStr := C.GEOSRelate_r(g.context.handle, g.geom, other.geom)
	defer C.GEOSFree_r(g.context.handle, unsafe.Pointer(relateCStr))
	return C.GoString(relateCStr)
}

// RelateBoundaryNodeRule returns the DE9IM pattern for g and other.
func (g *Geom) RelateBoundaryNodeRule(other *Geom, bnr RelateBoundaryNodeRule) string {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	relateBoundaryNodeRuleCStr := C.GEOSRelateBoundaryNodeRule_r(g.context.handle, g.geom, other.geom, C.int(bnr))
	defer C.GEOSFree_r(g.context.handle, unsafe.Pointer(relateBoundaryNodeRuleCStr))
	return C.GoString(relateBoundaryNodeRuleCStr)
}

// Reverse returns g with sequence orders reversed.
func (g *Geom) Reverse() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSReverse_r(g.context.handle, g.geom), nil)
}

// SetPrecision changes the coordinate precision of g.
func (g *Geom) SetPrecision(gridSize float64, flags PrecisionRule) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSGeom_setPrecision_r(g.context.handle, g.geom, C.double(gridSize), C.int(flags)), nil)
}

// SharedPaths returns the paths shared between g and other, which must be lineal geometries.
func (g *Geom) SharedPaths(other *Geom) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSSharedPaths_r(g.context.handle, g.geom, other.geom), nil)
}

// Simplify returns a simplified geometry.
func (g *Geom) Simplify(tolerance float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSSimplify_r(g.context.handle, g.geom, C.double(tolerance)), nil)
}

// Snap returns a geometry with the vertices and segments of g snapped to other within the given tolerance.
func (g *Geom) Snap(other *Geom, tolerance float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSSnap_r(g.context.handle, g.geom, other.geom, C.double(tolerance)), nil)
}

// StartPoint returns the first point of a LineString.
func (g *Geom) StartPoint() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSGeomGetStartPoint_r(g.context.handle, g.geom), nil)
}

// SymDifference returns the symmetric difference between g and other.
func (g *Geom) SymDifference(other *Geom) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSSymDifference_r(g.context.handle, g.geom, other.geom), nil)
}

// SymDifferencePrec returns the symmetric difference between g and other.
func (g *Geom) SymDifferencePrec(other *Geom, gridSize float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSSymDifferencePrec_r(g.context.handle, g.geom, other.geom, C.double(gridSize)), nil)
}

// TopologyPreserveSimplify returns a simplified geometry preserving topology.
func (g *Geom) TopologyPreserveSimplify(tolerance float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSTopologyPreserveSimplify_r(g.context.handle, g.geom, C.double(tolerance)), nil)
}

// Touches returns true if g touches other.
func (g *Geom) Touches(other *Geom) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSTouches_r(g.context.handle, g.geom, other.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// UnaryUnion returns the union of all components of a single geometry.
func (g *Geom) UnaryUnion() *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSUnaryUnion_r(g.context.handle, g.geom), nil)
}

// UnaryUnionPrec returns the union of all components of a single geometry.
func (g *Geom) UnaryUnionPrec(gridSize float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newNonNilGeom(C.GEOSUnaryUnionPrec_r(g.context.handle, g.geom, C.double(gridSize)), nil)
}

// Union returns the union of g and other.
func (g *Geom) Union(other *Geom) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSUnion_r(g.context.handle, g.geom, other.geom), nil)
}

// UnionPrec returns the union of g and other.
func (g *Geom) UnionPrec(other *Geom, gridSize float64) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.newGeom(C.GEOSUnionPrec_r(g.context.handle, g.geom, other.geom, C.double(gridSize)), nil)
}

// Within returns true if g is within other.
func (g *Geom) Within(other *Geom) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.GEOSWithin_r(g.context.handle, g.geom, other.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

// X returns g's X coordinate.
func (g *Geom) X() float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var x float64
	if C.GEOSGeomGetX_r(g.context.handle, g.geom, (*C.double)(&x)) == 0 {
		panic(g.context.err)
	}
	return x
}

// Y returns g's Y coordinate.
func (g *Geom) Y() float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var y float64
	if C.GEOSGeomGetY_r(g.context.handle, g.geom, (*C.double)(&y)) == 0 {
		panic(g.context.err)
	}
	return y
}
