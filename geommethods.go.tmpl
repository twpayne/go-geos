// This file is automatically generated. DO NOT EDIT.

package geos

// #include "go-geos.h"
import "C"

import "unsafe"

{{- range . }}
{{-   $geosFunction := printf "GEOS%s_r" .name }}
{{-   if .geosFunction }}
{{-     if eq .geosFunction $geosFunction }}
{{-       with printf "%s: do not set default .geosFunction" .name }}
{{-         fatal . }}
{{-       end }}
{{-     end }}
{{-     $geosFunction = .geosFunction }}
{{-   end }}
{{-   if not .comment }}
{{      with printf "%s: comment not set" .name }}
{{-       fatal . }}
{{-     end }}
{{-   end }}

{{-   if eq .type "unary" }}

{{ if .comment }}// {{ .name }} {{ .comment }}.{{ end }}
func (g *Geom) {{ .name }}({{ range $index, $arg := .extraArgs }}{{ if $index }}, {{ end }}{{ $arg.name }} {{ $arg.type }}{{ end }}) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	return g.context.new{{ if not .nil }}NonNil{{ end }}Geom(C.{{ $geosFunction }}(g.context.handle, g.geom{{ range .extraArgs }}, {{ .type | cType }}({{ .name }}){{ end }}), nil)
}

{{-   else if eq .type "binary" }}

{{ if .comment }}// {{ .name }} {{ .comment }}.{{ end }}
func (g *Geom) {{ .name }}(other *Geom{{ range .extraArgs }}, {{ .name }} {{ .type }}{{ end }}) *Geom {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	if other.context != g.context {
		other.context.Lock()
		defer other.context.Unlock()
	}
	return g.context.newGeom(C.{{ $geosFunction }}(g.context.handle, g.geom, other.geom{{ range .extraArgs }}, {{ .type | cType }}({{ .name }}){{ end }}), nil)
}

{{-   else if eq .type "unaryPredicate" }}

{{ if .comment }}// {{ .name }} {{ .comment }}.{{ end }}
func (g *Geom) {{ .name }}() bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	switch C.{{ $geosFunction }}(g.context.handle, g.geom) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

{{-   else if eq .type "binaryPredicate" }}

{{ if .comment }}// {{ .name }} {{ .comment }}.{{ end }}
func (g *Geom) {{ .name }}(other *Geom{{ range .extraArgs }}, {{ .name }} {{ .type }}{{ end }}) bool {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	if other.context != g.context {
		other.context.Lock()
		defer other.context.Unlock()
	}
	switch C.{{ $geosFunction }}(g.context.handle, g.geom, other.geom{{ range .extraArgs }}, {{ .type | cType }}({{ .name }}){{ end }}) {
	case 0:
		return false
	case 1:
		return true
	default:
		panic(g.context.err)
	}
}

{{-   else if eq .type "float64Property" }}
{{-     $varName := .name | firstRuneToLower }}

{{ if .comment }}// {{ .name }} {{ .comment }}.{{ end }}
func (g *Geom) {{ .name }}() float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	var {{ $varName }} float64
    if C.{{ $geosFunction }}(g.context.handle, g.geom, (*C.double)(&{{ $varName }})) == 0 {
		panic(g.context.err)
	}
	return {{ $varName }}
}

{{-   else if eq .type "float64BinaryProperty" }}
{{-     $varName := .name | firstRuneToLower }}

{{ if .comment }}// {{ .name }} {{ .comment }}.{{ end }}
func (g *Geom) {{ .name }}(other *Geom{{ range .extraArgs }}, {{ .name }} {{ .type }}{{ end }}) float64 {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	if other.context != g.context {
		other.context.Lock()
		defer other.context.Unlock()
	}
    {{- if .valueReturned }}
	return float64(C.{{ $geosFunction }}(g.context.handle, g.geom, other.geom{{ range .extraArgs }}, {{ .type | cType }}({{ .name }}){{ end }}))
    {{- else }}
	var {{ $varName }} float64
	if C.{{ $geosFunction }}(g.context.handle, g.geom, other.geom{{ range .extraArgs }}, {{ .type | cType }}({{ .name }}){{ end }}, (*C.double)(&{{ $varName }})) == 0 {
		panic(g.context.err)
	}
	return {{ $varName }}
    {{- end }}
}

{{-   else if eq .type "stringBinaryProperty" }}
{{-     $varName := .name | firstRuneToLower }}

{{ if .comment }}// {{ .name }} {{ .comment }}.{{ end }}
func (g *Geom) {{ .name }}(other *Geom{{ range .extraArgs }}, {{ .name }} {{ .type }}{{ end }}) string {
	g.mustNotBeDestroyed()
	g.context.Lock()
	defer g.context.Unlock()
	if other.context != g.context {
		other.context.Lock()
		defer other.context.Unlock()
	}
	{{ $varName }}CStr := C.{{ $geosFunction }}(g.context.handle, g.geom, other.geom{{ range .extraArgs }}, {{ .type | cType }}({{ .name }}){{ end }})
	defer C.GEOSFree_r(g.context.handle, unsafe.Pointer({{ $varName }}CStr))
	return C.GoString({{ $varName }}CStr)
}

{{-  end }}

{{- end }}
